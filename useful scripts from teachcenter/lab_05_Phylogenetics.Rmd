---
title: "Phylogenetic Analysis"
author: "MOL.923 Computerlabor Bioinformatik (WS 2025)"
date: "21/11/2025"
output: html_document
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


***

### Learning Objectives

- Infer trees using distance based methods, maximum  parsimony and maximum likelihood. 
- compare and interpret different trees. 
- plot trees in publication quality.

***


## Getting started


We start loading the required packages: 
```{R}
library(ape)
library(phangorn)
```

Next we import the alignement for the genes we prepared yesterday.

```{R }
TTR <- read.phyDat("data_edited/TTR_clustalo.fasta", type="DNA", format="fasta")
RAG2 <- read.phyDat("data_edited/RAG2_clustalo.fasta", type="DNA", format="fasta")
```
Next we concatenate these two files and also save this file. For this the labels of the alignments need to match. That's why we replaced the accession numbers with he species names. 

```{R }
two_genes <- cbind(RAG2, TTR)
image(two_genes)
names(two_genes) <- abbreviateGenus(names(two_genes))
write.phyDat(two_genes, "data_edited/two_genes.fasta", format="fasta")
```
Looking at the plot can you spot where the genes are? How do they differ? 
Create an folder results!

Perform an analysis with this data set [iqtree](http://iqtree.cibiv.univie.ac.at/). 


## Distance based methods, Neighbor Joining

Neighbor Joining needs a distance matrix as input.
So we first create a distance matrix:

```{R distance_matrix, eval=TRUE, results="hide"}
dm <- dist.ml(two_genes, "F81", exclude = "pairwise")
```

Using the distance matrix we can compute a Neighbor Joining (NJ) or UPGMA tree.

```{R NJ, eval=TRUE}
tree_NJ <- NJ(dm)
tree_UPGMA <- upgma(dm)
```

And we can plot these trees using the plot function:

```{R plot_NJ, eval=FALSE}
par(mar = c(1,1,2,1)) # smaller margins
plot(midpoint(tree_NJ), cex = 0.5)
plot(tree_UPGMA, cex = 0.5)
```

What is the difference between the 2 trees?

You can get a lot of inspiration if you look into the help typing `?plot.phylo`.
You can check what the arguments do but many function also have some examples and you can click on a link `run examples` it will just do this and can get see what different arguments in use.

Now we export the 2 trees so that they can read into other programs (e.g. figtree or dendrogram) or use  another time.

```{R export_NJ_tree, eval=TRUE}
write.tree(tree_NJ, file="figures/tree_NJ.phy")
write.tree(tree_UPGMA, "figures/tree_UPGMA.phy")
```

Always make sure that each steps work.
Check that the files contain a Newick string.

## Maximum Parsimony

Next we perform Maximum Parsimony. We can compute the number of substitutions which are necessary on a tree to describe the data using: 
```{R p_score, eval=TRUE}
parsimony(tree_NJ, two_genes)
parsimony(tree_UPGMA, two_genes)
```
Next we try to find the best maximum parimony tree.  Here we need only one command to execute and it will return a tree, which already has bootstrap values assigned to it.

```{R parsimony, eval=TRUE, cache=TRUE, results='hide'}
set.seed(42)
tree_MP <- pratchet(two_genes)
# we need to run this function ro assign edge length to the tree
tree_MP <- acctran(tree_MP, two_genes)
```

We can use the function **plot** plots the tree with Bootstrap values using the 
argument **show.node.label**. 


```{R plot_parsimony, eval=FALSE, fig.show='hide'}
par(mar = c(1,1,2,1)) # smaller margins
plot(tree_MP, type = "phylogram", show.node.label=TRUE,)
```

Try different **types** of the trees. Which one do you like most?

We artificial root the tree as it looks a bit better and add a `scalebar` and title to the plot.

```{R plot_parsimony_nicer, eval=FALSE, fig.show='hide'}
plot(midpoint(tree_MP), type = "phylogram", show.node.label=TRUE,
     main="Maximum Parsimony")
add.scale.bar()
```

Clicking on **export** button in Plots tab you can save each graphic.
Much nicer than doing screen shots!!



```{R, eval=TRUE}
write.tree(tree_MP, "fig/tree_MP.phy")
```
You can read in these trees later with `read.tree` or `read.nexus`. 


## Maximum Likelihood Analysis

Maximum Likelihood needs to set and optimize a lot of parameters. **modelTest** is a little helper functions which guides us to selecting the best model for your data set. We estimate some of the most common models. 

```{R modelTest, eval=TRUE, cache=TRUE, results='hide'}
set.seed(42)
mt <- modelTest(two_genes, model = c("JC", "F81", "K80", "HKY", "SYM", "GTR"))
```
```{R show_modelTest}
mt
```

What is the best (lowest) fitting model according to the Akaike Information Criteria (AIC) and the Bayesian Information Criteria (BIC) for your dataset?
Are AIC and the BIC agreeing?
We can use this object to optimize the tree with the best fitting model!

```{R pml_bb, eval=TRUE, cache=TRUE, echo=TRUE, results='hide'}
set.seed(42)
fit <- pml_bb(mt)
```
```{R pml_bb_print, eval=TRUE, cache=TRUE}
fit
```

We can extract the Maximum likelihood tree from the fit object using the `$` sign.

```{R export_ML, eval=TRUE}
tree_ML <- fit$tree
```


There is a generic **plot** function for **pml** objects. It has some default values set to 
plot the tree with Bootstrap values to the tree. Look for a parameter to plot only support values if these are larger than a threshold, e.g. 80%.

```{R plot_ML, eval=TRUE}
plot(fit, type = "p", show.node.label=TRUE, main="Maximum Likelihood")
```

In the console you can also execute the command `add.scale.bar(ask=TRUE)` to move 
the scale bar to a location you like. 

Export the tree.
```{R export_pml, eval=FALSE}
write.pml(fit, "results/two_genes")
```

## Plotting trees
 
We seen already two functions to plot trees `plotBS` and `plot`, which is actually a function called `plot.phylo`. `plotBS` is based on `plot.phylo` adding the bootstrap values on the tree, but otherwise can
take all the parameters of `plot.phylo`. 


## Rooting trees

MP, ML and NJ return unrooted trees. Usually we plot trees as rooted trees. 

```{R midpoint, eval=FALSE}
# plot two trees nexto to each other
par(mfrow=c(1,2))
tree_ML <- reorder(tree_ML)
tree_ML_midpoint <- midpoint(tree_ML)
plot(tree_ML, type="p", tip.col=tip_color[tree_MP$tip.label])

plot(tree_ML_midpoint, type="p")
# change parameters back, only one plot in a figure!
par(mfrow=c(1,1))
```

Often we know beforehand what the outgroup is. Here we assume  "Hyaena hyaena" and "Suricata suricatta" form an outgroup. We can root the tree so that  the outgroup are on one side of the root and the rest of the tree on the other one. This allows us to find the last common ancestor of the sequences. 
```{R root, eval=FALSE}
par(mfrow=c(1,2))
tree_ML_rooted <- root(tree_ML, c("Hyaena hyaena", "Suricata suricatta"))
plot(tree_ML, type="p")

plot(tree_ML_rooted, type="p")
par(mfrow=c(1,1))
```
If the outgroup should on the one hand close related to the other sequences, but if it is not monophyletic the function will return an error. So it should be avoided that species in the outgroup cluster with other sequences. 



## Comparing trees

1.  Are the NJ, UPGMA, Maximum Parsimony and the Maximum Likelihood tree the same?
2.  What trees are more similar?

When you executed all code chunks above you should have all the files in the results folder and can reload them again

```{R read_trees, eval=FALSE}
library(phangorn)
# Read in the trees if they are not in the environment any more
tree_MP <- read.tree("results/tree_MP.phy")
tree_ML <- read.tree("results/tree_ML.phy")
tree_NJ <- read.tree("results/tree_NJ.phy")
tree_UPGMA <- read.tree("results/tree_UPGMA.phy")
```

One way to compare trees is using the Robinson-Foulds (RF) distance [@Robinson1981].
Here we build a distance matrix between all trees we computed.
Which ones are more similar?

```{R Robinson-Foulds, eval=TRUE}
dm_RF <- RF.dist(c(tree_NJ, tree_UPGMA, tree_MP, tree_ML))
dm_RF <- as.matrix(dm_RF)
dimnames(dm_RF) <- list(c("NJ", "UPGMA", "MP", "ML"), c("NJ", "UPGMA", "MP", "ML"))
dm_RF
```

To compare two trees (also) there is the following function.

```{R comparePhylo_1, eval=TRUE}
comparePhylo(tree_MP, tree_ML, plot=TRUE, type="p", node.depth=2)
```

Change plotting style, e.g. plotting an unrooted tree instead of a phylogram (see `?plot.phylo`).
It is possible to change the font size and have flexibility to move the legend around.

```{R comparePhylo_2, eval=TRUE}
comparePhylo(tree_ML, tree_MP, plot=TRUE, type="unrooted", lab4ut="axial", location = list(x = 8, y = -2), cex=.5)
```

I prefer often to highlight differences not shared splits.

```{R comparePhylo_3, eval=TRUE}
comparePhylo(tree_ML, tree_MP, plot=TRUE, lab4ut="axial", type="p",
             cex=.5, commons=FALSE, node.depth=2)
```

When comparing different trees from different genes or gene trees with the species tree often the often the sets of species differ.
In such a case we can prune all the trees to have the same tip label.

Lets create a maximum parsimony tree for the "TTR" gene first.

```{r TTR_MP, cache=TRUE, eval=TRUE}
tree_TTR <- pratchet(TTR, trace=0)
tree_TTR <- acctran(tree_TTR, TTR)
```

The function `intersect` takes the intersection of two vectors.

```{r intersect, eval=FALSE}
shared_labels <- intersect(tree_TTR$tip.label, tree_MP$tip.label)
shared_labels
```

We can prune the trees to the shared labels and compare them:

```{r prune_trees, eval=FALSE}
tree_TTR_pr <- keep.tip(tree_TTR, shared_labels)
tree_MP_pr <- keep.tip(tree_MP, shared_labels)
comparePhylo(midpoint(tree_TTR_pr), midpoint(tree_MP_pr), plot=TRUE,  
             type="p", cex=.5, commons=FALSE, node.depth=2 
             location=c(1,1))
```


Compare the ML tree from phangorn with one from iqtree.  
You can read in the tree with `read.tree`. 




## References


